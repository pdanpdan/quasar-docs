(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[120],{"6a97":function(t,e,a){"use strict";a.r(e);var s=function(){var t=this,e=t._self._c;return e("doc-page",{attrs:{"meta-title":t.metaTitle,title:"Electron Static Assets",nav:t.nav,toc:t.toc,"meta-desc":t.metaDesc}},[e("p",[t._v("Please read about "),e("doc-link",{attrs:{to:"/quasar-cli/handling-assets"}},[t._v("Handling Assets")]),t._v(" first, which applies to the renderer process. However, when we deal with Electron then Quasar CLI offers a handy "),e("code",{staticClass:"doc-token"},[t._v("__static")]),t._v(" variable in addition. Statics can be consumed by both the main process and renderer process, but since the paths change when building for production (due to packaging), then usage with "),e("code",{staticClass:"doc-token"},[t._v("fs")]),t._v(" and other modules that need a full path can be a little tricky. So "),e("code",{staticClass:"doc-token"},[t._v("__statics")]),t._v(" can come into play.")],1),e("div",{staticClass:"doc-note doc-note--warning"},[e("p",{staticClass:"doc-note__title"},[t._v("WARNING")]),e("p",[t._v("These features require that you don’t disable the "),e("doc-link",{attrs:{to:"/quasar-cli/developing-electron-apps/node-integration"}},[t._v("Node Integration")]),t._v(".")],1)]),e("h2",{staticClass:"doc-heading doc-h2",attrs:{id:"on-the-subject-of-using-dirname-and-filename"},on:{click:function(e){return t.copyHeading("on-the-subject-of-using-dirname-and-filename")}}},[t._v("On the subject of using __dirname & __filename")]),e("p",[t._v("Since the main process is bundled using webpack, the use of "),e("code",{staticClass:"doc-token"},[t._v("__dirname")]),t._v(" and "),e("code",{staticClass:"doc-token"},[t._v("__filename")]),t._v(" will not provide an expected value in production. Referring to the File Tree, you’ll notice that in production the electron-main.js is placed inside the "),e("code",{staticClass:"doc-token"},[t._v("dist/electron-*")]),t._v(" folder. Based on this knowledge, use "),e("code",{staticClass:"doc-token"},[t._v("__dirname")]),t._v(" & "),e("code",{staticClass:"doc-token"},[t._v("__filename")]),t._v(" accordingly.")]),e("pre",{pre:!0,attrs:{class:"doc-code language-bash"}},[e("code",{pre:!0,attrs:{class:"doc-code__inner doc-code__inner--prerendered language-bash"}},[t._v("app.asar\n└─ dist\n   └─ electron-*\n      ├─ js/"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n      ├─ node_modules/\n      ├─ index.html\n      ├─ package.json\n      ├─ electron-main.js\n      └─ "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".contents of /public\n")])]),e("h2",{staticClass:"doc-heading doc-h2",attrs:{id:"static-assets-with-fs-path-and-statics"},on:{click:function(e){return t.copyHeading("static-assets-with-fs-path-and-statics")}}},[t._v("Static assets with fs, path and __statics")]),e("p",[t._v("Let’s say we have a static asset that we need to read into our application using "),e("code",{staticClass:"doc-token"},[t._v("fs")]),t._v(", but how do we get a reliable path, in both development and production, to the statics/ folder? Quasar provides a global variable named "),e("code",{staticClass:"doc-token"},[t._v("__statics")]),t._v(" that will yield a proper path to it. Here’s how we can use it to read a simple text file in both development and production.")]),e("p",[t._v("Let’s assume we have a file called "),e("code",{staticClass:"doc-token"},[t._v("someFile.txt")]),t._v(" in "),e("code",{staticClass:"doc-token"},[t._v("/public")]),t._v(". Now, in main or renderer process, we can access it like this:")]),e("pre",{pre:!0,attrs:{class:"doc-code language-bash"}},[e("code",{pre:!0,attrs:{class:"doc-code__inner doc-code__inner--prerendered language-bash"}},[t._v("// main or renderer process\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("import")]),t._v(" fs from "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fs'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("import")]),t._v(" path from "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'path'")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" fileContents "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fs.readFileSync"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  path.join"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__statics, "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/someFile.txt'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(",\n  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'utf8'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])},n=[],o=a("8669"),i={name:"DocMarkdownPage",created:function(){this.metaTitle="Electron Static Assets",this.metaDesc="Handling the static assets in a Quasar desktop app.",this.nav=[{name:"Build Commands",category:"Developing Electron Apps",path:"/quasar-cli/developing-electron-apps/build-commands",dir:"left"},{name:"Frameless Electron Window",category:"Developing Electron Apps",path:"/quasar-cli/developing-electron-apps/frameless-electron-window",dir:"right"}],this.toc=[{id:"on-the-subject-of-using-dirname-and-filename",title:"On the subject of using __dirname & __filename"},{id:"static-assets-with-fs-path-and-statics",title:"Static assets with fs, path and __statics"}],this.copyHeading=o["a"]}},c=i,r=a("2877"),d=Object(r["a"])(c,s,n,!1,null,null,null);e["default"]=d.exports}}]);